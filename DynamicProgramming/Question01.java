package DynamicProgramming;

public class Question01 {
    /*1. Dynamic Programming (DP):

Technique to solve problems by breaking them down into overlapping subproblems.

Used for optimization problems where the solution can be constructed from solutions to subproblems.

2. Overlapping Subproblems:

Same subproblems are solved multiple times in a recursive approach.

DP avoids redundant work by storing results and reusing them.

3. Optimal Substructure:

The problem’s solution can be constructed from the optimal solutions of its subproblems.

Ensures that solving smaller subproblems leads to the best solution for the whole problem.

4. Memoization (Top-Down):

Recursion + Caching: Solve subproblems recursively and store results to avoid recomputation.

Reduces time complexity by reusing stored results.

5. Tabulation (Bottom-Up):

Iteration + Table: Solve subproblems in a specific order, building up to the solution from base cases.

Uses an array or table to store subproblem solutions iteratively.

6. State:

The description of a subproblem’s current condition or configuration.

Represents what needs to be solved at each step.

7. Transition:

The rule or formula to compute the next state from the current state.

Defines how to go from one subproblem to the next.

8. Time Complexity:

The amount of time it takes to solve the problem using DP.

Often reduced from exponential (O(2^n)) to polynomial (O(n)) with DP.

9. Space Complexity:

The amount of memory needed to store the results of subproblems.

Can be optimized based on the problem’s structure (e.g., saving only necessary states).

     */
}
